<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CONSULTAS - Coca-Cola</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <div id="login-container">
    <form id="login-form">
      <h2>Iniciar Sesi√≥n</h2>
      <input type="text" id="username" name="username" placeholder="Usuario (email)" autocomplete="username" required>
      <input type="password" id="password" name="password" placeholder="Contrase√±a" autocomplete="current-password" required>
      <button type="submit">Entrar</button>
      <a href="admin.html" style="display: block; margin-top: 15px; text-align: center; color: var(--color-primary); font-size: 0.9rem; text-decoration: none; font-weight: 600;">‚öôÔ∏è Panel de Administraci√≥n</a>
    </form>
  </div>

  <div id="contenido" class="hidden">
    <header>
      <h1>CONSULTAS</h1>
      <button id="logout-btn" class="btn-logout" aria-label="Cerrar sesi√≥n">üö™ Cerrar Sesi√≥n</button>
    </header>
    <main>
      <div class="dropdown-container"><div id="filter-container"></div></div>
      <section id="product-list" aria-live="polite"></section>
    </main>
  </div>

  <div id="fullscreen-modal" class="fullscreen-modal-overlay hidden">
    <span class="close-fullscreen-modal">&times;</span>
    <div class="fullscreen-modal-content"></div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-auth.js";
    import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
    import { getStorage, ref, getDownloadURL, listAll } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyA3SNRVPID2Gz85UhESHr_OEdxsL1PNodM",
      authDomain: "cocacolaconsultas-20759.firebaseapp.com",
      projectId: "cocacolaconsultas-20759",
      storageBucket: "cocacolaconsultas-20759.firebasestorage.app",
      messagingSenderId: "274074684363",
      appId: "1:274074684363:web:b988c76c7e74f9e1e3444e",
      measurementId: "G-29GJZ22GMM"
    };
    
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    const loginContainer = document.getElementById("login-container");
    const contenidoDiv = document.getElementById("contenido");
    const loginForm = document.getElementById("login-form");
    const headerH1 = document.querySelector("#contenido header h1");
    const logoutBtn = document.getElementById("logout-btn");

    function mostrarContenido() {
      loginContainer.style.display = "none";
      contenidoDiv.classList.remove("hidden");
    }

    onAuthStateChanged(auth, user => {
      if (user) {
        mostrarContenido();
        localStorage.setItem("loggedInUser", user.email);
        loadImagesFromStorageBatched();
      } else {
        loginContainer.style.display = "flex";
        contenidoDiv.classList.add("hidden");
      }
    });

    loginForm.addEventListener("submit", e => {
      e.preventDefault();
      const email = document.getElementById("username").value.trim();
      const password = document.getElementById("password").value.trim();
      
      if (!email || !password) {
        alert("Por favor ingresa usuario y contrase√±a.");
        return;
      }
      
      signInWithEmailAndPassword(auth, email, password)
        .then(() => {
          console.log("‚úÖ Login exitoso");
          mostrarContenido();
        })
        .catch(err => {
          console.error(err);
          alert("Credenciales incorrectas.");
        });
    });

    logoutBtn.addEventListener("click", async () => {
      if (!confirm("¬øEst√°s seguro de que quieres cerrar sesi√≥n?")) return;
      try {
        await signOut(auth);
        localStorage.removeItem("loggedInUser");
      } catch (error) {
        console.error("Error al cerrar sesi√≥n:", error);
        alert("‚ùå Error al cerrar sesi√≥n");
      }
    });

    // CARGA BAJO DEMANDA (optimizada para memoria)
    // Solo cargamos las URLs cuando se necesitan, no todas de una vez
    async function loadImagesFromStorageBatched() {
      try {
        // Inicializar mapa vac√≠o - las URLs se cargar√°n bajo demanda
        window.firebaseImageUrls = window.firebaseImageUrls || {};
        window.firebaseImageFolders = window.firebaseImageFolders || {};
        
        // Solo cachear la estructura de carpetas, no las URLs
        const baseRef = ref(storage, 'images/');
        const top = await listAll(baseRef);
        
        // Guardar referencias de carpetas para carga bajo demanda
        const folders = top.prefixes || [];
        for (const folderRef of folders) {
          const folderName = folderRef.name;
          window.firebaseImageFolders[folderName] = folderRef;
        }
        
        console.log(`‚úÖ Estructura de carpetas cargada: ${folders.length} carpetas`);
        
        if (typeof window.updateProductImages === 'function') {
          window.updateProductImages();
        }
      } catch (e) {
        console.error('Error en carga por lotes:', e);
      }
    }

    // ACTUALIZAR IM√ÅGENES (asigna data-full bajo demanda)
    window.updateProductImages = function() {
      // No precargar todas las URLs aqu√≠
      // El lazy loading se encargar√° de cargarlas cuando se necesiten
      document.querySelectorAll('.product img[data-src]').forEach(img => {
        // Solo asignar si ya est√° en cach√©
        const storagePath = img.dataset.src.trim();
        const map = window.firebaseImageUrls || {};
        const url = map[storagePath];
        if (url) {
          img.dataset.full = url;
          if (!img.classList.contains('lazy')) img.src = url;
        }
      });
    };

    // LAZY LOADING ON-DEMAND OPTIMIZADO (con l√≠mites de memoria)
    window.lazyLoadImages = function() {
      const imgs = Array.from(document.querySelectorAll('img.lazy'));
      if (!imgs.length) return;

      const map = window.firebaseImageUrls = window.firebaseImageUrls || {};
      
      // L√≠mite de im√°genes cargadas simult√°neamente
      let activeLoads = 0;
      const MAX_CONCURRENT_LOADS = 3; // Reducido para evitar sobrecarga
      const MAX_CACHE_SIZE = 200; // M√°ximo de URLs en cach√©
      
      // Limpiar cach√© si excede el l√≠mite (mantener las m√°s recientes)
      function cleanupCache() {
        const keys = Object.keys(map);
        if (keys.length > MAX_CACHE_SIZE) {
          // Eliminar las m√°s antiguas (m√°s de MAX_CACHE_SIZE)
          const toRemove = keys.slice(0, keys.length - MAX_CACHE_SIZE);
          toRemove.forEach(key => delete map[key]);
          console.log(`üßπ Limpieza de cach√©: ${toRemove.length} URLs eliminadas`);
        }
      }

      async function ensureUrl(key) {
        if (map[key]) return map[key];
        
        // Esperar si hay demasiadas cargas activas
        while (activeLoads >= MAX_CONCURRENT_LOADS) {
          await new Promise(r => setTimeout(r, 50));
        }
        
        try {
          activeLoads++;
          const url = await getDownloadURL(ref(storage, key));
          map[key] = url;
          cleanupCache(); // Limpiar si es necesario
          return url;
        } catch (e) {
          console.error(`Error cargando imagen ${key}:`, e);
          return null;
        } finally {
          activeLoads--;
        }
      }

      async function loadOne(img) {
        // Si ya tiene src, no cargar de nuevo
        if (img.src && !img.src.includes('data:')) return;
        
        const key = (img.dataset.src || '').trim();
        if (!key) return;
        
        const url = await ensureUrl(key);
        if (url) {
          img.dataset.full = url;
          img.src = url;
          img.classList.remove('lazy');
          if (observer) observer.unobserve(img);
        }
      }

      // IntersectionObserver con rootMargin reducido para cargar menos im√°genes a la vez
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver((entries) => {
          // Procesar solo las visibles (una a la vez para evitar sobrecarga)
          entries.forEach(e => {
            if (e.isIntersecting && e.target.classList.contains('lazy')) {
              // Cargar con un peque√±o delay para evitar picos de memoria
              setTimeout(() => loadOne(e.target), Math.random() * 100);
            } else if (!e.isIntersecting && !e.target.classList.contains('lazy')) {
              // Si la imagen sale del viewport, liberar memoria (opcional, m√°s agresivo)
              // Solo liberar si hay muchas im√°genes cargadas para evitar recargas constantes
              const allLoaded = document.querySelectorAll('img:not(.lazy)').length;
              if (allLoaded > 50) {
                const img = e.target;
                if (img.dataset.full && !img.closest('.fullscreen-modal-overlay')) {
                  // No liberar si est√° en el modal
                  img.src = '';
                  img.classList.add('lazy');
                  observer.observe(img);
                }
              }
            }
          });
        }, { 
          rootMargin: '100px 0px', // Reducido de 200px para cargar menos im√°genes
          threshold: 0.01 
        });
        
        imgs.forEach(img => observer.observe(img));
        
        // Limpiar observador cuando ya no se necesite
        window.imageObserver = observer;
      } else {
        // Fallback: cargar una por vez con delay
        imgs.forEach((img, index) => {
          setTimeout(() => loadOne(img), index * 100);
        });
      }
    };

    // FULLSCREEN MODAL CON NAVEGACI√ìN SWIPE/FLECHAS
    window.initFullscreenModal = function() {
      const productList = document.getElementById('product-list');
      const modal = document.getElementById('fullscreen-modal');
      const modalContent = modal.querySelector('.fullscreen-modal-content');
      const closeBtn = modal.querySelector('.close-fullscreen-modal');

      let currentSection = [];
      let currentIndex = 0;
      
      // Variables para zoom t√°ctil
      let currentZoom = 1;
      let currentPanX = 0;
      let currentPanY = 0;
      let isZooming = false;
      let initialDistance = 0;
      let initialZoom = 1;
      let initialPanX = 0;
      let initialPanY = 0;
      let lastTouchX = 0;
      let lastTouchY = 0;
      let isPanning = false;

      function openModal(card) {
        const section = card.closest('.section');
        const allCards = Array.from(section.querySelectorAll('.product[data-section-name]'));
        currentSection = allCards.filter(c => c.querySelector('img[data-full]'));
        currentIndex = currentSection.indexOf(card);

        // Resetear zoom al abrir nueva imagen
        currentZoom = 1;
        currentPanX = 0;
        currentPanY = 0;

        showImage(currentIndex);
        modal.classList.remove('hidden');
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      function showImage(index) {
        if (index < 0 || index >= currentSection.length) return;
        
        const card = currentSection[index];
        const cardImg = card.querySelector('img[data-full]');
        const src = cardImg?.dataset.full || cardImg?.src;
        if (!src) return;

        const prevDisabled = index === 0 ? 'style="opacity:0.3;pointer-events:none;"' : '';
        const nextDisabled = index === currentSection.length - 1 ? 'style="opacity:0.3;pointer-events:none;"' : '';

        // Limpiar imagen anterior para liberar memoria antes de cargar nueva
        const oldImg = modalContent.querySelector('img');
        if (oldImg) {
          oldImg.src = '';
          oldImg.remove();
        }
        
        // Limpiar zoom al cambiar imagen
        currentZoom = 1;
        currentPanX = 0;
        currentPanY = 0;
        
        // Crear nueva imagen y precargar
        const newImg = document.createElement('img');
        newImg.src = src;
        newImg.alt = `Imagen ${index + 1}`;
        newImg.title = 'Doble toque para ampliar / Pellizca para zoom';
        newImg.loading = 'eager'; // Cargar inmediatamente en modal
        newImg.className = 'zoomable-image';
        newImg.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
        newImg.style.transformOrigin = 'center center';
        newImg.style.transition = currentZoom === 1 ? 'transform 0.3s ease' : 'none';
        
        modalContent.innerHTML = `
          <button class="modal-nav modal-nav-prev" ${prevDisabled}>‚Äπ</button>
          <button class="modal-nav modal-nav-next" ${nextDisabled}>‚Ä∫</button>
          <div class="modal-counter">${index + 1} / ${currentSection.length}</div>
        `;
        
        modalContent.appendChild(newImg);

        modalContent.querySelector('.modal-nav-prev')?.addEventListener('click', () => navigate(-1));
        modalContent.querySelector('.modal-nav-next')?.addEventListener('click', () => navigate(1));

        // Zoom y navegaci√≥n
        setupImageZoom(newImg);
        
        // Pantalla completa al hacer doble clic en imagen
        let clickTimer = null;
        newImg.addEventListener('click', (e) => {
          if (e.detail === 1) {
            clickTimer = setTimeout(() => {
              // Solo clic simple despu√©s de delay
              if (currentZoom === 1) {
                toggleRealFullscreen(e);
              }
            }, 300);
          } else if (e.detail === 2) {
            clearTimeout(clickTimer);
            toggleZoom(e);
          }
        });
      }

      function navigate(direction) {
        // No navegar si est√° haciendo zoom
        if (isZooming) return;
        
        const newIndex = currentIndex + direction;
        if (newIndex >= 0 && newIndex < currentSection.length) {
          currentIndex = newIndex;
          showImage(currentIndex);
        }
      }
      
      function setupImageZoom(img) {
        // Resetear zoom variables
        isZooming = false;
        isPanning = false;
        
        // Touch events para zoom con pellizco
        img.addEventListener('touchstart', handleTouchStart, { passive: false });
        img.addEventListener('touchmove', handleTouchMove, { passive: false });
        img.addEventListener('touchend', handleTouchEnd, { passive: false });
      }
      
      function handleTouchStart(e) {
        if (e.touches.length === 2) {
          // Gestos de pellizco (zoom)
          isZooming = true;
          e.preventDefault();
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          
          initialDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          initialZoom = currentZoom;
          initialPanX = currentPanX;
          initialPanY = currentPanY;
        } else if (e.touches.length === 1 && currentZoom > 1) {
          // Pan cuando est√° ampliada
          isPanning = true;
          e.preventDefault();
          
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        }
      }
      
      function handleTouchMove(e) {
        if (e.touches.length === 2 && isZooming) {
          // Calcular zoom con pellizco
          e.preventDefault();
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          
          const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          const scale = currentDistance / initialDistance;
          currentZoom = Math.max(1, Math.min(initialZoom * scale, 5)); // L√≠mite entre 1x y 5x
          
          const img = modalContent.querySelector('.zoomable-image');
          if (img) {
            img.style.transition = 'none';
            img.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
          }
        } else if (e.touches.length === 1 && isPanning && currentZoom > 1) {
          // Pan cuando est√° ampliada
          e.preventDefault();
          
          const touch = e.touches[0];
          const deltaX = touch.clientX - lastTouchX;
          const deltaY = touch.clientY - lastTouchY;
          
          // L√≠mites para el pan basados en el zoom
          const maxPan = (currentZoom - 1) * 200;
          currentPanX = Math.max(-maxPan, Math.min(maxPan, currentPanX + deltaX));
          currentPanY = Math.max(-maxPan, Math.min(maxPan, currentPanY + deltaY));
          
          const img = modalContent.querySelector('.zoomable-image');
          if (img) {
            img.style.transition = 'none';
            img.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
          }
          
          lastTouchX = touch.clientX;
          lastTouchY = touch.clientY;
        }
      }
      
      function handleTouchEnd(e) {
        if (e.touches.length === 0) {
          isZooming = false;
          isPanning = false;
          
          // Resetear si el zoom es muy peque√±o
          if (currentZoom < 1.1) {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            
            const img = modalContent.querySelector('.zoomable-image');
            if (img) {
              img.style.transition = 'transform 0.3s ease';
              img.style.transform = 'translate(0px, 0px) scale(1)';
            }
          }
        }
      }
      
      function toggleZoom(e) {
        const img = e.target;
        if (currentZoom === 1) {
          currentZoom = 2;
        } else {
          currentZoom = 1;
          currentPanX = 0;
          currentPanY = 0;
        }
        
        img.style.transition = 'transform 0.3s ease';
        img.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
      }

      function closeModal() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        modal.classList.remove('active');
        setTimeout(() => {
          modal.classList.add('hidden');
          modalContent.innerHTML = '';
          document.body.style.overflow = '';
        }, 400);
      }

      async function toggleRealFullscreen(e) {
        const img = e.target;
        if (!img) return;

        try {
          if (!document.fullscreenElement) {
            if (img.requestFullscreen) {
              await img.requestFullscreen();
            } else if (img.webkitRequestFullscreen) {
              await img.webkitRequestFullscreen();
            } else if (img.msRequestFullscreen) {
              await img.msRequestFullscreen();
            }
            img.classList.add('in-fullscreen');
          } else {
            if (document.exitFullscreen) {
              await document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              await document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
              await document.msExitFullscreen();
            }
            img.classList.remove('in-fullscreen');
          }
        } catch (err) {
          console.error('Error al cambiar pantalla completa:', err);
        }
      }

      document.addEventListener('fullscreenchange', () => {
        const img = modalContent.querySelector('img');
        if (img && !document.fullscreenElement) {
          img.classList.remove('in-fullscreen');
        }
      });

      // Touch/Swipe support con protecci√≥n contra gestos de pellizco y zoom
      let touchStartX = 0;
      let touchEndX = 0;
      let touchStartY = 0;
      let touchEndY = 0;
      let isPinchGesture = false;
      let touchCount = 0;

      // Detectar si es un gesto de pellizco (2 dedos) o swipe
      modalContent.addEventListener('touchstart', e => {
        // No procesar swipe si est√° sobre la imagen y hay zoom activo o gestos de pellizco
        const img = e.target.closest('.zoomable-image');
        if (img && (e.touches.length >= 2 || currentZoom > 1)) {
          return; // Dejar que los handlers de zoom se encarguen
        }
        
        touchCount = e.touches.length;
        
        // Si hay 2 o m√°s dedos, es un gesto de pellizco - no hacer swipe
        if (touchCount >= 2) {
          isPinchGesture = true;
          return;
        }
        
        // Solo un dedo - guardar posici√≥n inicial
        isPinchGesture = false;
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: true });

      modalContent.addEventListener('touchmove', e => {
        // No procesar swipe si est√° sobre la imagen ampliada
        const img = e.target.closest('.zoomable-image');
        if (img && currentZoom > 1) {
          return;
        }
        
        if (e.touches.length >= 2) {
          isPinchGesture = true;
        }
      }, { passive: true });

      modalContent.addEventListener('touchend', e => {
        // No procesar swipe si est√° sobre la imagen ampliada o hubo pellizco
        const img = e.target.closest('.zoomable-image');
        if (img && currentZoom > 1) {
          return;
        }
        
        touchCount = e.touches.length;
        
        if (isPinchGesture) {
          if (touchCount >= 1) {
            return;
          }
          setTimeout(() => {
            isPinchGesture = false;
            touchCount = 0;
          }, 100);
          return;
        }
        
        if (touchCount === 0 && e.changedTouches.length === 1) {
          touchEndX = e.changedTouches[0].screenX;
          touchEndY = e.changedTouches[0].screenY;
          handleSwipe();
        }
        
        if (touchCount === 0) {
          isPinchGesture = false;
        }
      }, { passive: true });

      function handleSwipe() {
        // No hacer swipe si hay zoom activo o fue un pellizco
        if (isPinchGesture || currentZoom > 1 || isZooming) return;
        
        const deltaX = Math.abs(touchStartX - touchEndX);
        const deltaY = Math.abs(touchStartY - touchEndY);
        
        const swipeThreshold = 50;
        const minVerticalRatio = 2;
        
        if (deltaX > swipeThreshold && deltaX > deltaY * minVerticalRatio) {
          if (touchStartX - touchEndX > swipeThreshold) {
            navigate(1);
          } else if (touchEndX - touchStartX > swipeThreshold) {
            navigate(-1);
          }
        }
      }

      // Teclado
      document.addEventListener('keydown', e => {
        if (!modal.classList.contains('active')) return;
        if (e.key === 'ArrowLeft') navigate(-1);
        if (e.key === 'ArrowRight') navigate(1);
        if (e.key === 'Escape') closeModal();
      });

      // Variables para controlar la sensibilidad del modal
      let lastClickTime = 0;
      let clickTimeout = null;
      const DOUBLE_CLICK_DELAY = 300; // ms entre clics para considerar doble clic
      const MIN_CLICK_DELAY = 200; // ms m√≠nimo entre clics para evitar activaciones accidentales

      productList.addEventListener('click', e => {
        const card = e.target.closest('.product');
        if (card && card.querySelector('img[data-full]') && !e.target.closest('button,input,a')) {
          e.preventDefault();
          
          const currentTime = Date.now();
          
          // Evitar clics muy r√°pidos (accidentales)
          if (currentTime - lastClickTime < MIN_CLICK_DELAY) {
            return;
          }
          
          // Si es el primer clic, esperar un poco para ver si hay un segundo clic
          if (currentTime - lastClickTime > DOUBLE_CLICK_DELAY) {
            clickTimeout = setTimeout(() => {
              // Solo un clic - abrir modal despu√©s de un peque√±o delay
              setTimeout(() => openModal(card), 100);
            }, DOUBLE_CLICK_DELAY);
          } else {
            // Segundo clic dentro del tiempo - cancelar timeout y abrir inmediatamente
            if (clickTimeout) {
              clearTimeout(clickTimeout);
              clickTimeout = null;
            }
            openModal(card);
          }
          
          lastClickTime = currentTime;
        }
      });

      closeBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', e => {
        if (e.target === modal) closeModal();
      });
    };

    window.auth = auth;
    window.firebaseApp = app;
    window.db = db;
    window.firebaseStorage = storage;
  </script>

  <script src="script.js?v=2025101301"></script>
</body>
</html>
